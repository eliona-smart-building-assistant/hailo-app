/*
 * Hailo app API
 *
 * API to access and configure the Hailo app
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package apiserver

// Configuration - Each configuration defines access to an Hailo FDS endpoint with configurable timeouts and polling intervals. Each FDS endpoint delivers information about a set of Hailo smart devices.
type Configuration struct {

	// Internal identifier for the configured endpoint (created automatically). This identifier have to use always if you remove or update existing configured endpoints.
	Id int32 `json:"id,omitempty"`

	// Login for authentication endpoint
	Username string `json:"username"`

	// Password for authentication endpoint
	Password string `json:"password"`

	// Url to Hailo authentication endpoint
	AuthServer string `json:"auth_server"`

	// Url to Hailo FDS endpoint
	FdsServer string `json:"fds_server"`

	// Flag to enable or disable the endpoint
	Enable bool `json:"enable,omitempty"`

	// Description of the endpoint
	Description string `json:"description,omitempty"`

	// Id of an parent asset with groups all device assets
	AssetId int32 `json:"asset_id,omitempty"`

	// Interval in seconds for collecting data from endpoint
	IntervalSec int32 `json:"interval_sec,omitempty"`

	// Timeout in seconds for authentication server
	AuthTimeout int32 `json:"auth_timeout,omitempty"`

	// Timeout in seconds for FDS server
	RequestTimeout int32 `json:"request_timeout,omitempty"`

	// Set to `true` by the app when running and to `false` when app is stopped
	Active bool `json:"active,omitempty"`

	// List of Eliona project ids for which this endpoint should collect data. For each pair of project id and Hailo smart device identifier found in the configured endpoint an asset is automatically created in Eliona. This mapping of project id and device id on the one hand and the Eliona asset id on the other hand is separately stored by the Hailo app (see `AssetMapping`).
	ProjIds []string `json:"proj_ids,omitempty"`
}

// AssertConfigurationRequired checks if the required fields are not zero-ed
func AssertConfigurationRequired(obj Configuration) error {
	elements := map[string]interface{}{
		"username":    obj.Username,
		"password":    obj.Password,
		"auth_server": obj.AuthServer,
		"fds_server":  obj.FdsServer,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	return nil
}

// AssertRecurseConfigurationRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Configuration (e.g. [][]Configuration), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseConfigurationRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aConfiguration, ok := obj.(Configuration)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertConfigurationRequired(aConfiguration)
	})
}
